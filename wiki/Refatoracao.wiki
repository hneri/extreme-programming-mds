= Refatoração = 

 * Refatoração é o processo de modificar um sistema de software de tal modo que não altere o comportamento externamente observável e ainda melhora sua estrutura interna (Fowler, 99).
 * É um modo disciplinado de limpar o código e que minimiza as chances de introduzir bugs (Fowler, 99).
 * De fato, ao refatorar você melhora o código e seu projeto depois deles terem sido escritos. 

-----------
Em um desenvolvimento “tradicional”, inicialmente é feito o projeto e posteriormente a codificação. A Refatoração permite executar no sentido oposto: artefatos de código podem ser alterados de modo a melhorar o projeto de software. Essas alterações em código são realizadas em pequenos passos, de modo muito controlado e simples.

Com Refatoração, atividades de projeto são constantes durante o desenvolvimento do software. O efeito cumulativo dessas mudanças é que promoverá melhorias significativas no projeto.

----
==Bad Smells in Code==

Kent Beck, um dos criadores da Programação Extrema, afirma que refatoração deve ser utilizada quando o "código cheirar mal" (do inglês bad smells in code). Este conselho bem humorado indica uma confiança na experiência de programadores e também ressalta o valor estético do código, que deve valorizar a clareza e comunicação.

Saber refatorar (executar cada operação de refatoração) não te faz um bom projetista refatorador. É preciso saber quando (início e término).

“Maus cheiros” de código são pontos em que há possibilidades para aplicação de refatoração. Maus cheiros são pontos em que princípios de bom projeto não são considerados ou podem ser melhorados.

Entretanto estes pontos de melhorias não são precisos: o julgamento do refatorador é quem vai decidir quais operações podem e devem ser aplicadas. 
Este julgamento vem na medida em que o projetista ganha familiaridade com as operações de refatoração.

-----------

== Maus cheiros: ==

 # Código duplicado: Se o mesmo trecho de código aparecer em vários pontos do projeto, saiba que sua solução será melhor se você conseguir unificá-los.
 # Método longo: Quanto maior for o  método, mais difícil é de entendê-lo. Vários métodos curtos (e a delegação entre eles) é preferível. Vários métodos ajudam a aumentar coesão e diminuir acoplamento (por meio de indireção).
 # Classe grande: Quando uma classe apresenta muitas variáveis de instâncias é indício de que ela está com coesão baixa (fazendo mais do que deveria). Classes com muito código indica que há grandes chances de haver código duplicado.
 # Longa lista de parâmetros: Listas de parâmetros longas são difíceis de entender, pois se tornam inconsistentes e difíceis de usar. 
 # Mudanças divergentes: idealmente mudanças em uma classe devem ser realizadas de modo pontual. 
 # Cirurgia com rifle: É o oposto da mudança com rifle: ao realizar uma mudança várias classes devem sofrer modificações. É difícil de encontrar todos os lugares afetados, e fácil de esquecer alguma modificação. 
 # Inveja de recursos: Quando métodos de uma classe estão mais interessados nos recursos de outras classes (geralmente atributos).
 # Aglomerado de dados: É comum que alguns itens de dados apareçam em conjunto em alguns pedaços do código de diversas formas possíveis. Tais itens podem ser transformados em objetos.
 # Obsessão primitiva: Tipos de dados primitivos são oferecidos por todas as linguagens: int, float, boolean, etc... À partir destes tipos de dados primitivos são formadas estruturas maiores, tais como registros e classes. 
 # Instruções Switch: Em OO é comum ver a mesma instrução *switch ... case* em diversos pontos do projeto (duplicação de código). Solução mais elegante para este comando é o uso de polimorfismo.
 # Hierarquias de heranças paralelas: Caso especial de cirurgia com rifle: sempre que adicionar uma subclasse em um ramo, terá que adicionar a mesma subclasse no outro ramo. É também indício de duplicação de código. 
 # Classe Preguiçosa: Classes que não possuem comportamento suficiente para ser mantida no projeto, ou seja, pequena demais deve ser eliminada do projeto.
 # Generalidade Especulativa: Projetos que são genéricos demais, em que o projetista fez previsões de funcionalidades que algum dia poderiam vir a ser implementadas. São projetos difíceis de entender e manter.
 # Campo temporário: Ocorre quando algumas variáveis de instância de um objeto são utilizadas apenas em algum contexto específico (e não a maior parte dela).
 # Cadeias de mensagens: Ocorre quando um objeto chama outro, que chama outro, que chama outro e assim sucessivamente.
 # Homem do meio: Caso em que a indireção é indesejável. Os métodos de uma classe simplesmente delegam a execução para métodos de outras classes. 
 # Intimidade inapropriada: Algumas vezes uma classe torna muito íntima das demais, o que permite que ela investigue as partes privadas das outras classes. O ideal é que essa relação seja a mais restrita possível. 
 # Classes alternativas com interfaces diferentes: Métodos que fazem a mesma coisa mas que apresentam assinaturas diferentes, conforme as classes às quais estão ligadas.
 # Biblioteca de classes incompleta: Muitas vezes é comum encontrar bibliotecas de classes que não oferecem todos os recursos dos quais precisamos. Além disso, não conseguimos ter acesso ao seu fonte para modificá-lo.
 # Classe de dados: Classes que possuem apenas campos de dados, métodos set e get. São classes simples demais e que certamente são muito utilizadas pelas demais classes da aplicação. 
 # Herança negada: Subclasses herdam métodos e dados de suas classes-pai, mas nem sempre gostariam de herdá-los. Nesses casos há um indício claro que a hierarquia está errada. 

-----------
== Maus cheiros e operações de refatoração == 

Descrição das principais operações de refatoração que são aplicadas quando os maus cheiros de código são encontrados.

[http://extreme-programming-mds.googlecode.com/svn/wiki/Sele%C3%A7%C3%A3o_032.png]
[http://extreme-programming-mds.googlecode.com/svn/wiki/Sele%C3%A7%C3%A3o_033.png]